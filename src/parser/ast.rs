use crate::parser::lexer::Token;
use std::iter::Peekable;


// usage of all these commands on existing tables is like
//  INSERT <table_name> VALUES (...)
// Not regular SQL syntax where would do INSERT INTO.

#[derive(Debug)]
pub enum Query {
    Select(SelectQuery),
    Insert(InsertQuery),
    // Update(UpdateQuery),
    Delete(DeleteQuery),
    Create(CreateQuery),
}

#[derive(Debug)]
pub struct SelectQuery {
    pub table_name: String,
    pub columns: Vec<String>,
    pub where_clause: Option<Expression>,
}

#[derive(Debug)]
pub struct InsertQuery {
    pub table_name: String,
    pub values: Vec<String>,
}

// #[derive(Debug)]
// pub struct UpdateQuery {
//     pub updates: Vec<String>,
//     pub where_clause: Option<Expression>,
// }

#[derive(Debug)]
pub struct DeleteQuery {
    pub table_name: String,
    pub where_clause: Option<Expression>,
}

#[derive(Debug)]
pub struct CreateQuery {
    pub table_name: String,
    pub columns: Vec<String>,
}

#[derive(Debug)]
pub enum Expression {
    BinaryOp {
        left: Box<Expression>,
        operator: String,
        right: Box<Expression>,
    },
    Column(String),
    Value(String),
}

/// Parses a list of tokens into a `Query` structure.
///
/// # Arguments
/// - `tokens`: A vector of tokens generated by the lexer.
///
/// # Returns
/// - `Result<Query, String>`: A `Query` structure on success, or an error message on failure.
pub fn parse_tokens(tokens: Vec<Token>) -> Result<Query, String> {
    let mut tokens_iter = tokens.into_iter().peekable();

    match tokens_iter.next() {
        Some(Token::Select) => parse_select_query(&mut tokens_iter),
        Some(Token::Insert) => parse_insert_query(&mut tokens_iter),
        // Some(Token::Update) => parse_update_query(&mut tokens_iter),
        Some(Token::Delete) => parse_delete_query(&mut tokens_iter),
        Some(Token::Create) => parse_create_query(&mut tokens_iter),
        _ => Err("Unsupported query type".to_string()),
    }
}

fn parse_select_query(tokens: &mut Peekable<std::vec::IntoIter<Token>>) -> Result<Query, String> {
    let mut columns = Vec::new();
    let mut table_name = String::new();
    // peek to not consume 'where'
    while let Some(token_ref) = tokens.peek() {
        match token_ref {
            Token::Identifier(_) => {
                // just sets table name to first identifier found
                if table_name.is_empty() {
                    if let Some(Token::Identifier(name)) = tokens.next() {
                        table_name = name;
                    }
                } else {
                if let Some(Token::Identifier(column)) = tokens.next() {
                        columns.push(column);
                    }
                }
            }
            Token::Comma => {
                tokens.next(); // consume comma
                continue;
            }
            Token::Where => break,
            _ => return Err("Unexpected token in SELECT query".to_string()),
        }
    }

    // If a WHERE token is present, consume it and attempt to parse the
    // expression. If parsing fails, return an explicit error instead of
    // silently treating the WHERE as absent.
    let where_clause = if let Some(Token::Where) = tokens.peek() {
        tokens.next(); // Consume WHERE
        match parse_expression(tokens) {
            Some(expr) => Some(expr),
            None => return Err("Failed to parse WHERE expression".to_string()),
        }
    } else {
        None
    };

    Ok(Query::Select(SelectQuery {
        table_name,
        columns,
        where_clause,
    }))
}

fn parse_insert_query(tokens: &mut Peekable<std::vec::IntoIter<Token>>) -> Result<Query, String> {
    let table_name = if let Some(Token::Identifier(name)) = tokens.next() {
        name
    } else {
        return Err("Expected table name after INSERT".to_string());
    };

    if tokens.next() != Some(Token::Values) {
        return Err("Expected VALUES after INSERT".to_string());
    }

    let mut values = Vec::new();

    while let Some(token) = tokens.next() {
        match token {
            Token::ParenOpen => continue,
            Token::ParenClose => break,
            Token::Comma => continue,
            Token::StringLiteral(some_string) => {
                values.push(some_string.clone());
            }
            _ => return Err("Unexpected token in INSERT query".to_string()),
        }
    }

    Ok(Query::Insert(InsertQuery { table_name,values }))
}

// fn parse_update_query(tokens: &mut Peekable<std::vec::IntoIter<Token>>) -> Result<Query, String> {
//     if tokens.next() != Some(Token::Set) {
//         return Err("Expected SET after UPDATE".to_string());
//     }

//     let mut updates = Vec::new();

//     while let Some(token) = tokens.next() {
//         match token {
//             Token::Identifier(column) => {
//                 if let Some(Token::Operator(op)) = tokens.next() {
//                     if op == "=" {
//                         if let Some(Token::StringLiteral(value)) = tokens.next() {
//                             updates.push(value);
//                         } else {
//                             return Err("Expected value after =".to_string());
//                         }
//                     } else {
//                         return Err("Expected = after column name".to_string());
//                     }
//                 } else {
//                     return Err("Expected = after column name".to_string());
//                 }
//             }
//             Token::Comma => continue,
//             Token::Where => break,
//             _ => return Err("Unexpected token in UPDATE query".to_string()),
//         }
//     }

//     let where_clause = if let Some(Token::Where) = tokens.peek() {
//         tokens.next(); // Consume WHERE
//         parse_expression(tokens)
//     } else {
//         None
//     };

//     Ok(Query::Update(UpdateQuery {
//         updates,
//         where_clause,
//     }))
// }

fn parse_delete_query(tokens: &mut Peekable<std::vec::IntoIter<Token>>) -> Result<Query, String> {
    let table_name = if let Some(Token::Identifier(name)) = tokens.next() {
        name
    } else {
        return Err("Expected table name after DELETE".to_string());
    };
    let where_clause = if let Some(Token::Where) = tokens.peek() {
        tokens.next(); // Consume WHERE
        parse_expression(tokens)
    } else {
        None
    };

    Ok(Query::Delete(DeleteQuery { table_name, where_clause }))
}

fn parse_create_query(tokens: &mut Peekable<std::vec::IntoIter<Token>>) -> Result<Query, String> {
    // create should be like "CREATE table_name (col1, col2, ...)"
    let table_name = if let Some(Token::Identifier(name)) = tokens.next() {
        name
    } else {
        return Err("Expected table name after CREATE".to_string());
    };
    
    if tokens.next() != Some(Token::ParenOpen) {
        return Err(format!("Expected ( after table name {}", table_name));
    }
    let mut columns = Vec::new();
    while let Some(token) = tokens.next() {
        match token {
            Token::Identifier(column) => {
                columns.push(column);
            }
            Token::Comma => continue,
            Token::ParenClose => break,
            _ => return Err("Unexpected token in CREATE query".to_string()),
        }
    }
    Ok(Query::Create(CreateQuery {
        table_name,
        columns,
    }))
}

fn parse_expression(tokens: &mut Peekable<std::vec::IntoIter<Token>>) -> Option<Expression> {
    let left = match tokens.next() {
        Some(Token::Identifier(column)) => Expression::Column(column),
        Some(Token::StringLiteral(value)) => Expression::Value(value),
        _ => return None,
    };

    if let Some(Token::Operator(op)) = tokens.next() {
        let right = match tokens.next() {
            Some(Token::Identifier(column)) => Expression::Column(column),
            Some(Token::StringLiteral(value)) => Expression::Value(value),
            _ => return None,
        };

        Some(Expression::BinaryOp {
            left: Box::new(left),
            operator: op,
            right: Box::new(right),
        })
    } else {
        None
    }
}

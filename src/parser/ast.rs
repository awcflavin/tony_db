use crate::parser::lexer::Token;
use std::iter::Peekable;

#[derive(Debug)]
pub enum Query {
    Select(SelectQuery),
    Insert(InsertQuery),
    Update(UpdateQuery),
    Delete(DeleteQuery),
}

#[derive(Debug)]
pub struct SelectQuery {
    pub columns: Vec<String>,
    pub where_clause: Option<Expression>,
}

#[derive(Debug)]
pub struct InsertQuery {
    pub values: Vec<String>,
}

#[derive(Debug)]
pub struct UpdateQuery {
    pub updates: Vec<String>,
    pub where_clause: Option<Expression>,
}

#[derive(Debug)]
pub struct DeleteQuery {
    pub where_clause: Option<Expression>,
}

#[derive(Debug)]
pub enum Expression {
    BinaryOp {
        left: Box<Expression>,
        operator: String,
        right: Box<Expression>,
    },
    Column(String),
    Value(String),
}

/// Parses a list of tokens into a `Query` structure.
///
/// # Arguments
/// - `tokens`: A vector of tokens generated by the lexer.
///
/// # Returns
/// - `Result<Query, String>`: A `Query` structure on success, or an error message on failure.
pub fn parse_tokens(tokens: Vec<Token>) -> Result<Query, String> {
    let mut tokens_iter = tokens.into_iter().peekable();

    match tokens_iter.next() {
        Some(Token::Select) => parse_select_query(&mut tokens_iter),
        Some(Token::Insert) => parse_insert_query(&mut tokens_iter),
        Some(Token::Update) => parse_update_query(&mut tokens_iter),
        Some(Token::Delete) => parse_delete_query(&mut tokens_iter),
        _ => Err("Unsupported query type".to_string()),
    }
}

fn parse_select_query(tokens: &mut Peekable<std::vec::IntoIter<Token>>) -> Result<Query, String> {
    let mut columns = Vec::new();

    while let Some(token) = tokens.next() {
        match token {
            Token::Identifier(column) => columns.push(column),
            Token::Comma => continue,
            Token::Where => break,
            _ => return Err("Unexpected token in SELECT query".to_string()),
        }
    }

    let where_clause = if let Some(Token::Where) = tokens.peek() {
        tokens.next(); // Consume WHERE
        parse_expression(tokens)
    } else {
        None
    };

    Ok(Query::Select(SelectQuery {
        columns,
        where_clause,
    }))
}

fn parse_insert_query(tokens: &mut Peekable<std::vec::IntoIter<Token>>) -> Result<Query, String> {
    if tokens.next() != Some(Token::Values) {
        return Err("Expected VALUES after INSERT".to_string());
    }

    let mut values = Vec::new();

    while let Some(token) = tokens.next() {
        match token {
            Token::ParenOpen => continue,
            Token::ParenClose => break,
            Token::Comma => continue,
            Token::StringLiteral(some_string) => {
                values.push(some_string.clone());
            }
            _ => return Err("Unexpected token in INSERT query".to_string()),
        }
    }

    Ok(Query::Insert(InsertQuery { values }))
}

fn parse_update_query(tokens: &mut Peekable<std::vec::IntoIter<Token>>) -> Result<Query, String> {
    if tokens.next() != Some(Token::Set) {
        return Err("Expected SET after UPDATE".to_string());
    }

    let mut updates = Vec::new();

    while let Some(token) = tokens.next() {
        match token {
            Token::Identifier(column) => {
                if let Some(Token::Operator(op)) = tokens.next() {
                    if op == "=" {
                        if let Some(Token::StringLiteral(value)) = tokens.next() {
                            updates.push(value);
                        } else {
                            return Err("Expected value after =".to_string());
                        }
                    } else {
                        return Err("Expected = after column name".to_string());
                    }
                } else {
                    return Err("Expected = after column name".to_string());
                }
            }
            Token::Comma => continue,
            Token::Where => break,
            _ => return Err("Unexpected token in UPDATE query".to_string()),
        }
    }

    let where_clause = if let Some(Token::Where) = tokens.peek() {
        tokens.next(); // Consume WHERE
        parse_expression(tokens)
    } else {
        None
    };

    Ok(Query::Update(UpdateQuery {
        updates,
        where_clause,
    }))
}

fn parse_delete_query(tokens: &mut Peekable<std::vec::IntoIter<Token>>) -> Result<Query, String> {

    let where_clause = if let Some(Token::Where) = tokens.peek() {
        tokens.next(); // Consume WHERE
        parse_expression(tokens)
    } else {
        None
    };

    Ok(Query::Delete(DeleteQuery { where_clause }))
}

fn parse_expression(tokens: &mut Peekable<std::vec::IntoIter<Token>>) -> Option<Expression> {
    let left = match tokens.next() {
        Some(Token::Identifier(column)) => Expression::Column(column),
        Some(Token::StringLiteral(value)) => Expression::Value(value),
        _ => return None,
    };

    if let Some(Token::Operator(op)) = tokens.next() {
        let right = match tokens.next() {
            Some(Token::Identifier(column)) => Expression::Column(column),
            Some(Token::StringLiteral(value)) => Expression::Value(value),
            _ => return None,
        };

        Some(Expression::BinaryOp {
            left: Box::new(left),
            operator: op,
            right: Box::new(right),
        })
    } else {
        None
    }
}
